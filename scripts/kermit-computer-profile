#!/bin/bash

# kermit's shell profile file
if [[ $PROFILE_SOURCED == TRUE ]]; then
    return # don't source us twice
fi

export PROFILE_SOURCED=TRUE

GIT=$HOME/code

# TODO: split all this into multiple files

# aliases
##########

alias g=git
alias be="bundle exec"

# - Emacs
alias ec=emacsclient
alias et="ec -t"
alias ed="emacs --daemon &"
alias ek="ec -e '(kill-emacs)' &"
alias ep="ps -e | grep -i emacs"

# - Python
alias s="workon s"
alias s3="workon s3"
alias py=python
alias py3=python3
alias ipy=ipython
alias ipy3=ipython3

# - Ruby
alias rbgrep="grep --include='*.rb' $*"
alias r="bundle exec rails"
alias rc="bundle exec rails console"
alias rcp="bundle exec rails console production"
alias rct="bundle exec rails console test"
alias rdb="bundle exec rails dbconsole"

# - docker-compose
alias fig=docker-compose
alias dku="docker-compose up"
alias dkr="docker-compose run"

# global functions
###################

function test_open() {
    echo "opening"
    open "http://localhost/"
}

function server() {
    local port="${1:-8000}"
    if [ -f `kermit-deploy-location`/kermit-app-server ]; then
        kermit-app-server "$port"
    else
        nohup python -m SimpleHTTPServer "$port" > /dev/null 2>&1 &
        open "http://localhost:${port}/"
    fi
}

# - docker cleanup
function docker-rm-exited() {
    docker rm $(docker ps -a -q -f status=exited)
}
function docker-rmi-none() {
    docker rmi $(docker images -a | grep '<none>' | awk '{print($3)}')
}

# - PATH stuff
function absolute_path() {
    echo $(cd $(dirname "$1") && pwd -P)/$(basename "$1")
}

export PATH

pathadd() {
    if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
        PATH="${PATH:+"$PATH:"}$1"
    fi
}

# - Ruby
rdbm () {
  if [ -f `pwd`/bin/rake ]
  then
    RAKE_CMD="./bin/rake"
  else
    RAKE_CMD="bundle exec rake"
  fi
  echo "Migrating dev database..."
  $RAKE_CMD db:migrate
  echo "Migrating test database..."
  $RAKE_CMD db:migrate RAILS_ENV=test
}

function routes() {
  if [ -n "$1" ]; then
    bundle exec rake routes | grep $1
  else
    bundle exec rake routes
  fi
}

# OS-specific
##################
if [[ "$OSTYPE" == "linux-gnu" ]]; then
    # Linux
    subl() { nohup /usr/bin/subl "$@" > /dev/null 2>&1 & }
    #e() { nohup emacs "$@" > /dev/null 2>&1 & }
    alias open=xdg-open
    alias edit=e
    #emacs --daemon # start the background daemon
    #ALTERNATE_EDITOR=""
    e() {
        nohup emacsclient -n --alternate-editor="emacs" "$@" > /dev/null 2>&1 &
    }
    export EDITOR_GUI=emacs
    export EDITOR_TERM="emacs -nw"
    #export EDITOR=emacsclient
    export EDITOR=kermit-edit
    alias rc='env DISPLAY=:0.0 rhythmbox-client --no-start'
    if [[ `hostname` == hocus-pocus ]]; then
        # key remappings for weird keyboards. Apple khm.. khm..
        # off due to switching to an us layout
        #xmodmap ~/.Xmodmap
        :
    fi
    # emacs-bindings: http://superuser.com/questions/345452
    #gsettings set org.gnome.desktop.interface gtk-key-theme "Emacs"
    # ssh keychain
    if type keychain >/dev/null 2>/dev/null; then
        keychain --nogui -q ~/.ssh/id_rsa
        [ -f ~/.keychain/${HOSTNAME}-sh ] && . ~/.keychain/${HOSTNAME}-sh
        [ -f ~/.keychain/${HOSTNAME}-sh-gpg ] && . ~/.keychain/${HOSTNAME}-sh-gpg
    fi

    if ! [ -f /usr/bin/docker ]; then
        alias docker="docker.io"
    fi

elif [[ "$OSTYPE" == "darwin"* ]]; then
    # Mac OS X
    #export PATH=/usr/texbin:$PATH
    pathadd '/usr/texbin'
    # Set CLICOLOR if you want Ansi Colors in iTerm2
    export CLICOLOR=1
    # Set colors to match iTerm2 Terminal Colors
    export TERM=xterm-256color
    # Change iterm2 profile. Usage it2prof ProfileName (case sensitive)
    it2prof() { echo -e "\033]50;SetProfile=$1\a" }
    # open Emacs GUI from terminal
    #alias emacs='open -a /Applications/Emacs.app $1'
    EMACS_PATH="/usr/local/Caskroom/emacs/24.4/Emacs.app/Contents/MacOS"
    if [ ! -d "$EMACS_PATH" ]; then
      # backup for when Emacs.app was manually installed
      EMACS_PATH="/Applications/Emacs.app/Contents/MacOS"
    fi
    #alias emacs="${EMACS_PATH}/Emacs"
    alias emacsclient=${EMACS_PATH}/bin/emacsclient
    EMACS_CLIENT_PATH="${EMACS_PATH}/bin/emacsclient"
    alias et="${EMACS_CLIENT_PATH} -t"
    alias ed="${EMACS_CLIENT_PATH} --daemon &"
    alias ek="${EMACS_CLIENT_PATH} -e '(kill-emacs)' &"
    alias ep="${EMACS_CLIENT_PATH} -e | grep -i emacs"
    e() {
      nohup ${EMACS_PATH}/bin/emacsclient \
      -n --alternate-editor="${EMACS_PATH}/Emacs" \
      "$@" > /dev/null 2>&1 &
    }
    export EDITOR_GUI=${EMACS_PATH}/Emacs
    export EDITOR_TERM="$EDITOR_GUI -nw"
    export EDITOR=kermit-edit # used to be emacsclient, then ${EMACS_PATH}/Emacs
    # set Chrome binary path
    CHROME_BIN=/usr/local/Caskroom/google-chrome/latest/Google\ Chrome.app/Contents/MacOS/Google\ Chrome
    if [ -f "$CHROME_BIN" ]; then
      export CHROME_BIN
    fi
    # brew wants this before /usr/bin
    export PATH="/usr/local/bin:$PATH"
    export PATH="/usr/local/sbin:$PATH"
    # find the local docker daemon

    # hopefully not needed after Docker for Mac
    # if [[ $(docker-machine ls | grep default) ]]; then
    #   eval "$(docker-machine env default)"
    # fi

    # redis start/stop shortcuts
    alias redisstart='sudo launchctl start io.redis.redis-server'
    alias redisstop='sudo launchctl stop io.redis.redis-server'
    # JDK path
    # for when Java is installed
    # if [ -f /usr/libexec/java_home ]; then
    #     export JAVA_HOME=`/usr/libexec/java_home -v 1.7`
    # fi
    # Postgres.app
    #pathadd "/Applications/Postgres.app/Contents/Versions/9.4/bin"
fi

# my scripts
#############
pathadd $HOME/.bin/scripts
pathadd $HOME/bin

# language support
####################
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# Deb packaging
################
export DEBFULLNAME="Dražen Lučanin"
export DEBEMAIL="kermit666@gmail.com"

# Python
########
# virtualenvwrapper sourced by zsh plugin / .bashrc
# - but it needs $WORKON_HOME defined (only the zsh plugin)
export WORKON_HOME=$HOME/.virtualenvs

# Ruby
######
pathadd '/var/lib/gems/1.8/bin'
pathadd $HOME/.rvm/bin
# Load RVM into a shell session *as a function*
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"
# rsense (Emacs auto-completion)
if hash rsense 2>/dev/null; then
    RSENSE_HOME=`which rsense`
fi

# Heroku
########
pathadd '/usr/local/heroku/bin'

# GO
#####
export GOPATH=$HOME/.go
mkdir -p $GOPATH/bin
pathadd ${GOPATH}/bin

# OCaml
#######
. $HOME/.opam/opam-init/init.zsh > /dev/null 2> /dev/null || true

# node
######
pathadd $HOME/.local/bin
[ -s $HOME/.nvm/nvm.sh ] && . $HOME/.nvm/nvm.sh # This loads NVM
[[ -r $NVM_DIR/bash_completion ]] && . $NVM_DIR/bash_completion
# yarn
pathadd `yarn global bin`

# Z script
##########
source ${GIT}/drugi/z/z.sh

# dev env variables
###################
API_keys_script=$HOME/Dropbox/dev/API-keys.sh
if [ -f $API_keys_script ]; then
    source $API_keys_script
fi

# Postgres functions
####################
pg() {
    DATA="$1"
    PORT=${2-5432}
    postgres -D $DATA -p $PORT
}

create-project-db() {
    U=$1
    DB=$2
    DBPATH=tmp/postgres
    PORT=9911

    initdb $DBPATH
    postgres -D $DBPATH -p $PORT &
    sleep 5
    PID=$!
    createuser -s -p $PORT $U
    createdb -p $PORT -O $U $DB
    echo "Created database $DB for user $U"

    kill -INT $PID
}

# password generation
#####################

genpasswd() {
    local l=$1
    [[ "$l" == "" ]] && l=16
    #tr -dc A-Za-z0-9 < /dev/urandom | head -c ${l} | xargs
    openssl rand -base64 $l
 }

# web performance
perf () {
    curl -o /dev/null -s -w "%{time_connect} + %{time_starttransfer} = %{time_total}\n" $@
}

# emoji
if [ -e ~/.emoji_vars.sh ]; then
    source ~/.emoji_vars.sh
fi
